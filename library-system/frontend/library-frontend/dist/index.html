<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Library - SOA</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: sans-serif; background: #f5f5f5; }
    header { background: #333; color: white; padding: 1rem; }
    nav { display: flex; gap: 1rem; }
    nav button { background: none; border: none; color: white; cursor: pointer; font-size: 1rem; }
    main { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
    .card { background: white; padding: 1.5rem; margin: 1rem 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    form { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
    input, button { padding: 0.5rem; font-size: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    button { background: #007bff; color: white; cursor: pointer; border: none; }
    button:hover { background: #0056b3; }
    .hidden { display: none; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem; }
    .book-card { background: white; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    .notification { background: #d4edda; color: #155724; padding: 1rem; margin: 0.5rem 0; border-radius: 4px; }
    .error { background: #f8d7da; color: #721c24; }
    #notifications { position: fixed; bottom: 1rem; right: 1rem; max-width: 400px; max-height: 300px; overflow-y: auto; }
    .row { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
  </style>
</head>
<body>
  <header>
    <nav>
      <h1>ðŸ“š Library SOA</h1>
      <button id="btnLogin" onclick="showLogin()">Login</button>
      <button id="btnBooks" onclick="showBooks()" class="hidden">Browse Books</button>
      <button id="btnMyBorrows" onclick="showMyBorrows()" class="hidden">My Borrows</button>
      <button id="btnLogout" onclick="logout()" class="hidden">Logout</button>
      <span id="userDisplay"></span>
    </nav>
  </header>

  <main>
    <!-- Login/Register -->
    <div id="loginSection" class="card">
      <h2>Login / Register</h2>
      <form onsubmit="handleAuth(event)">
        <input type="email" id="email" placeholder="Email" required />
        <input type="password" id="password" placeholder="Password" required />
        <input type="text" id="name" placeholder="Full Name (register only)" />
        <button type="submit" id="authBtn">Login</button>
      </form>
      <p id="authMessage"></p>
    </div>

    <!-- Books Section -->
    <div id="booksSection" class="hidden card">
      <h2>Browse Books</h2>
      <input type="text" id="searchBooks" placeholder="Search by title or author..." />
      <button onclick="searchBooks()">Search</button>
      <div class="row" style="margin-top: 0.75rem; align-items: center;">
        <label for="dueDays" style="min-width: 90px;">Due days:</label>
        <input type="number" id="dueDays" min="1" max="90" value="14" style="width: 110px;" oninput="updateDuePreview()" />
        <span id="duePreview" style="color:#555;"></span>
      </div>
      <div id="booksList" class="grid"></div>
    </div>

    <!-- My Borrows -->
    <div id="borrowsSection" class="hidden card">
      <h2>My Borrowed Books</h2>
      <div id="borrowsList"></div>
    </div>
  </main>

  <div id="notifications"></div>

  <script>
    const API_BASE = 'http://localhost:8080';
    let token = localStorage.getItem('token');
    let userId = localStorage.getItem('userId');
    let ws;
    let sseAbort;
    let booksCache = new Map();
    let borrowsCache = new Map();

    function updateUI() {
      const isLoggedIn = !!token;
      document.getElementById('btnLogin').classList.toggle('hidden', isLoggedIn);
      document.getElementById('btnBooks').classList.toggle('hidden', !isLoggedIn);
      document.getElementById('btnMyBorrows').classList.toggle('hidden', !isLoggedIn);
      document.getElementById('btnLogout').classList.toggle('hidden', !isLoggedIn);
      document.getElementById('loginSection').classList.toggle('hidden', isLoggedIn);
      if (isLoggedIn) {
        const userName = localStorage.getItem('userName');
        document.getElementById('userDisplay').textContent = userName ? `Welcome, ${userName}` : '';
        connectNotifications();
      } else {
        document.getElementById('userDisplay').textContent = '';
        document.getElementById('booksSection').classList.add('hidden');
        document.getElementById('borrowsSection').classList.add('hidden');
        document.getElementById('booksList').innerHTML = '';
        document.getElementById('borrowsList').innerHTML = '';
        disconnectNotifications();
      }
    }

    async function invokeFaas(name, input) {
      return await fetchJson(`${API_BASE}/faasapi/invoke/${encodeURIComponent(name)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input || {})
      });
    }

    function disconnectNotifications() {
      if (sseAbort) {
        try { sseAbort.abort(); } catch (e) { /* ignore */ }
        sseAbort = null;
      }
      if (ws) {
        try { ws.close(); } catch (e) { /* ignore */ }
        ws = null;
      }
    }

    function connectNotifications() {
      // Prefer SSE because it works cleanly through the API Gateway + NGINX with JWT headers.
      disconnectNotifications();
      if (!token) return;
      connectSSE();
    }

    async function connectSSE() {
      sseAbort = new AbortController();
      try {
        const res = await fetch(`${API_BASE}/notificationapi/events`, {
          method: 'GET',
          headers: { Authorization: 'Bearer ' + token },
          signal: sseAbort.signal
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `SSE HTTP ${res.status}`);
        }
        addNotification('Connected to notifications', 'success');

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          // SSE events are separated by blank lines
          const parts = buffer.split('\n\n');
          buffer = parts.pop() || '';

          for (const chunk of parts) {
            const lines = chunk.split('\n');
            let eventType = 'message';
            const dataLines = [];
            for (const line of lines) {
              if (line.startsWith('event:')) eventType = line.slice(6).trim();
              if (line.startsWith('data:')) dataLines.push(line.slice(5).trim());
            }
            if (!dataLines.length) continue;
            const dataStr = dataLines.join('\n');

            if (eventType === 'ping' || eventType === 'connected') continue;

            try {
              const payload = JSON.parse(dataStr);
              if (payload && payload.type && payload.data) {
                const title = payload.data.title;
                const author = payload.data.author;
                const bookId = payload.data.book_id;
                const bookLabel = title ? `${title}${author ? ` â€” ${author}` : ''}` : `Book ${bookId}`;
                const action = payload.type === 'book.borrowed'
                  ? 'Borrowed'
                  : payload.type === 'book.returned'
                    ? 'Returned'
                    : payload.type;
                addNotification(`ðŸ“¢ ${action}: ${bookLabel}`, 'success');
                if (payload.type === 'book.borrowed' || payload.type === 'book.returned') {
                  const booksSection = document.getElementById('booksSection');
                  if (booksSection && !booksSection.classList.contains('hidden')) {
                    await loadBooks();
                  }
                }
              }
            } catch (e) {
              // ignore parse failures
            }
          }
        }
      } catch (err) {
        if (err.name === 'AbortError') return;
        addNotification('Notifications disconnected: ' + err.message, 'error');
      }
    }

    // WebSocket support is intentionally not used here;
    // SSE via /notificationapi/events works through the gateway with JWT headers.

    function addNotification(text, type = 'info') {
      const div = document.createElement('div');
      div.className = `notification ${type === 'error' ? 'error' : ''}`;
      div.textContent = text;
      document.getElementById('notifications').appendChild(div);
      setTimeout(() => div.remove(), 5000);
    }

    // Helper to safely fetch JSON and handle HTML/error responses
    async function fetchJson(url, options = {}) {
      // attach auth header when token is present
      options = options || {};
      options.headers = options.headers || {};
      if (token && !options.headers.Authorization && !options.headers.authorization) {
        options.headers.Authorization = 'Bearer ' + token;
      }
      const res = await fetch(url, options);
      const contentType = res.headers.get('content-type') || '';
      if (!res.ok) {
        const text = await res.text();
        let body = text;
        if (contentType.includes('application/json')) {
          try { body = JSON.parse(text); } catch (e) { /* ignore */ }
        }
        if (res.status === 401) {
          // clear auth and redirect to login
          logout();
          throw new Error((body && (body.error || body.message)) || 'Unauthorized');
        }
        throw new Error((body && (body.error || body.message)) || text || `HTTP ${res.status}`);
      }
      if (contentType.includes('application/json')) return await res.json();
      return await res.text();
    }

    async function handleAuth(e) {
      e.preventDefault();
      const email = document.getElementById('email').value;
      const password = document.getElementById('password').value;
      const name = document.getElementById('name').value;
      
      try {
        const isRegister = name.trim().length > 0;
        const endpoint = isRegister ? '/userapi/register' : '/userapi/login';
        const body = isRegister ? { name, email, password } : { email, password };
        
        const data = await fetchJson(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (isRegister) {
          // Registration successful
          document.getElementById('authMessage').textContent = 'Account created! Please login with your credentials.';
          document.getElementById('name').value = '';
          document.getElementById('email').value = '';
          document.getElementById('password').value = '';
        } else {
          // Login successful
          if (data.token) {
            token = data.token;
            userId = data.user.id;
            localStorage.setItem('token', token);
            localStorage.setItem('userId', userId);
            if (data.user.name) localStorage.setItem('userName', data.user.name);
            document.getElementById('authMessage').textContent = 'Login successful!';
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
            updateUI();
            showBooks();
          } else {
            document.getElementById('authMessage').textContent = 'Login error: No token received';
          }
        }
      } catch (err) {
        document.getElementById('authMessage').textContent = 'Error: ' + err.message;
      }
    }

    async function showBooks() {
      document.getElementById('booksSection').classList.remove('hidden');
      document.getElementById('borrowsSection').classList.add('hidden');
      updateDuePreview();
      await loadBooks();
    }

    function getDueDays() {
      const el = document.getElementById('dueDays');
      const days = Number(el?.value);
      if (!Number.isFinite(days)) return 14;
      const wholeDays = Math.trunc(days);
      if (wholeDays < 1) return 1;
      if (wholeDays > 90) return 90;
      return wholeDays;
    }

    async function updateDuePreview() {
      const preview = document.getElementById('duePreview');
      if (!preview) return;

      const days = getDueDays();
      preview.textContent = 'Calculating due date...';

      try {
        // Real usage of FaaS: ask the FaaS service to compute the due date.
        // Uses JWT automatically via fetchJson().
        const result = await invokeFaas('dueDate', { days });
        const dueAt = result?.output?.due_at;
        const dueDateLocal = dueAt ? new Date(dueAt).toLocaleDateString() : '';
        preview.textContent = dueDateLocal ? `Due date: ${dueDateLocal}` : '';
      } catch (err) {
        // Fallback: don't block borrowing if FaaS is unavailable
        const due = new Date(Date.now() + days * 24 * 60 * 60 * 1000);
        preview.textContent = `Due date: ${due.toLocaleDateString()}`;
      }
    }

    async function loadBooks() {
      try {
        const data = await fetchJson(`${API_BASE}/bookapi/books?limit=20`);
        booksCache = new Map((data.books || []).map(b => [b.id, b]));
        const html = data.books.map(b => `
          <div class="book-card">
            <h3>${b.title}</h3>
            <p>Author: ${b.author}</p>
            <p>Available: ${b.copies_available}/${b.copies_total}</p>
            <button ${b.copies_available > 0 ? '' : 'disabled'} onclick="borrowBook(${b.id})">
              ${b.copies_available > 0 ? 'Borrow' : 'Not Available'}
            </button>
          </div>
        `).join('');
        document.getElementById('booksList').innerHTML = html;
      } catch (err) {
        addNotification('Error loading books: ' + err.message, 'error');
      }
    }

    async function searchBooks() {
      const q = document.getElementById('searchBooks').value;
      if (!q) return loadBooks();
      try {
        let books = await fetchJson(`${API_BASE}/bookapi/books/search/${encodeURIComponent(q)}`);
        // Handle both array and {books:[]} response
        if (books && books.books) books = books.books;
        if (!Array.isArray(books)) books = [];
        booksCache = new Map(books.map(b => [b.id, b]));
        const html = books.map(b => `
          <div class="book-card">
            <h3>${b.title}</h3>
            <p>Author: ${b.author}</p>
            <p>Available: ${b.copies_available ?? '-'} / ${b.copies_total ?? '-'}</p>
            <button ${b.copies_available > 0 ? '' : 'disabled'} onclick="borrowBook(${b.id})">
              ${b.copies_available > 0 ? 'Borrow' : 'Not Available'}
            </button>
          </div>
        `).join('');
        document.getElementById('booksList').innerHTML = html || '<p>No books found.</p>';
      } catch (err) {
        addNotification('Search error: ' + err.message, 'error');
      }
    }

    async function borrowBook(bookId) {
      try {
        const dueDays = getDueDays();
        await fetchJson(`${API_BASE}/borrowapi/borrow`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user_id: userId, book_id: bookId, due_days: dueDays })
        });
        // Success notifications come from SSE (/notificationapi/events)
        await loadBooks();
      } catch (err) {
        addNotification('Borrow error: ' + err.message, 'error');
      }
    }

    async function showMyBorrows() {
      document.getElementById('booksSection').classList.add('hidden');
      document.getElementById('borrowsSection').classList.remove('hidden');
      try {
        const borrows = await fetchJson(`${API_BASE}/borrowapi/borrows/${userId}`);
        borrowsCache = new Map((borrows || []).map(b => [b.id, b]));

        // Real FaaS integration: compute days remaining via FaaS based on due_at.
        let dueInfoByIndex = [];
        try {
          const dates = (borrows || []).map(b => b.due_at);
          const faas = await invokeFaas('daysUntil', { dates });
          if (Array.isArray(faas?.output)) dueInfoByIndex = faas.output;
        } catch (e) {
          // Fallback: compute locally if FaaS is unavailable
          dueInfoByIndex = (borrows || []).map(b => {
            const to = new Date(b.due_at);
            const ms = to.getTime() - Date.now();
            const days = Math.ceil(ms / (24 * 60 * 60 * 1000));
            return { days, overdue: days < 0 };
          });
        }

        const html = borrows.map(b => `
          <div class="card">
            <h3>${b.title}</h3>
            <p>Author: ${b.author}</p>
            <p>Borrowed: ${new Date(b.borrowed_at).toLocaleDateString()}</p>
            <p>Due: ${new Date(b.due_at).toLocaleDateString()}</p>
            ${!b.returned_at ? (() => {
              const idx = (borrows || []).findIndex(x => x.id === b.id);
              const info = dueInfoByIndex[idx];
              if (!info || typeof info.days !== 'number') return '';
              const label = info.overdue
                ? `Overdue by ${Math.abs(info.days)} day(s)`
                : `${info.days} day(s) remaining`;
              const color = info.overdue ? '#b00020' : '#155724';
              return `<p style="color:${color}; font-weight:600;">${label}</p>`;
            })() : ''}
            ${!b.returned_at
              ? `<button onclick="returnBook(${b.id})">Return</button>`
              : `<p>âœ“ Returned on ${new Date(b.returned_at).toLocaleDateString()}</p>`}
          </div>
        `).join('');
        document.getElementById('borrowsList').innerHTML = html || '<p>No active borrows</p>';
      } catch (err) {
        addNotification('Error loading borrows: ' + err.message, 'error');
      }
    }

    async function returnBook(borrowId) {
      try {
        await fetchJson(`${API_BASE}/borrowapi/return`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ borrow_id: borrowId })
        });
        // Success notifications come from SSE (/notificationapi/events)
        await showMyBorrows();
      } catch (err) {
        addNotification('Return error: ' + err.message, 'error');
      }
    }

    function logout() {
      token = null;
      userId = null;
      localStorage.removeItem('token');
      localStorage.removeItem('userId');
      localStorage.removeItem('userName');
      const authMsg = document.getElementById('authMessage');
      if (authMsg) authMsg.textContent = '';
      disconnectNotifications();
      showLogin();
      updateUI();
    }

    // Keep multiple tabs in sync: if one tab logs out, others should immediately reset UI
    window.addEventListener('storage', (e) => {
      if (e.key === 'token' && !e.newValue) {
        token = null;
        userId = null;
        disconnectNotifications();
        showLogin();
        updateUI();
      }
      // Some browsers emit a single event with key === null on clear(); handle that too
      if (e.key === null && !localStorage.getItem('token')) {
        token = null;
        userId = null;
        disconnectNotifications();
        showLogin();
        updateUI();
      }
    });

    function showLogin() {
      document.getElementById('loginSection').classList.remove('hidden');
      document.getElementById('booksSection').classList.add('hidden');
      document.getElementById('borrowsSection').classList.add('hidden');
      const authMsg = document.getElementById('authMessage');
      if (authMsg) authMsg.textContent = '';
    }

    updateUI();
  </script>
</body>
</html>
